package com.twitter.scrooge

import com.twitter.conversions.time._
import com.twitter.finagle.builder.{Server, ServerBuilder}
import com.twitter.finagle.stats.{StatsReceiver, OstrichStatsReceiver}
import com.twitter.finagle.thrift.ThriftServerFramedCodec
import com.twitter.finagle.tracing.{NullTracer, Tracer}
import com.twitter.finagle.Service
import com.twitter.logging.Logger
import com.twitter.ostrich
import com.twitter.util.{Duration, Future}
import java.net.InetSocketAddress
import java.util.concurrent.atomic.AtomicReference
import org.apache.thrift.protocol.{TBinaryProtocol, TProtocolFactory}

/**
 * This trait is intended as a near-drop-in replacement for the ThriftServer class generated by
 * scrooge, which will soon be no longer generated. To use this class, change your code from
 * "X extends Y.ThriftServer" to "X extends OstrichThriftServer with Y.FutureIface".
 *
 * Ostrich in general is now deprecated, and long-term, you should switch to twitter-server.
 */
trait OstrichThriftServer extends ostrich.admin.Service {
  val log = Logger.get(getClass)

  def thriftCodec = ThriftServerFramedCodec()
  def statsReceiver: StatsReceiver = new OstrichStatsReceiver
  def tracer: Tracer = NullTracer
  @deprecated("use tracer instead", "3.3.3")
  def tracerFactory: Tracer.Factory = NullTracer.factory
  val thriftPort: Int
  val serverName: String

  protected def finagleService: Service[Array[Byte], Array[Byte]] =
    getClass.getInterfaces.find(_.getName.endsWith("$FutureIface")) match {
      case None => throw new IllegalStateException("Can't infer Service class, you must implement finagleService method")
      case Some(iface) =>
        val serviceName = iface.getName.dropRight(12) + "$FinagledService"
        val serviceClass = Class.forName(serviceName)
        val constructor = serviceClass.getConstructor(iface, classOf[TProtocolFactory])
        constructor.newInstance(this, new TBinaryProtocol.Factory())
          .asInstanceOf[Service[Array[Byte], Array[Byte]]]
    }

  // Must be thread-safe as different threads can start and shutdown the service.
  private[this] val _server = new AtomicReference[Server]
  def server = _server.get
  def server_=(value: Server) = _server.set(value)

  def start() {
    server_=(serverBuilder.build(finagleService))
  }

  /**
   * You can override this to provide additional configuration
   * to the ServerBuilder.
   */
  def serverBuilder =
    ServerBuilder()
      .codec(thriftCodec)
      .name(serverName)
      .reportTo(statsReceiver)
      .bindTo(new InetSocketAddress(thriftPort))
      .tracer(tracer)

  /**
   * Close the underlying server gracefully with the given grace
   * period. close() will drain the current channels, waiting up to
   * ``timeout'', after which channels are forcibly closed.
   */
  def shutdown(timeout: Duration = 0.seconds) {
    synchronized {
      val s = server
      if (s != null) {
        s.close(timeout)
      }
    }
  }

  def shutdown() = shutdown(0.seconds)
}
